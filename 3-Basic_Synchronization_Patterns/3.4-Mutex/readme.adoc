# 3.4 Mutex

Mutexes, we got.  Anyway, let's play along for a bit.

## book.go

Here's the literal implementation of the solution from the book.  Note the
semaphore initialized to 1 rather than 0.

## countSem.go

The literal implementation again, this time with CountSem from our package,
demonstrating initialization of CountSem to something greater than zero.

## mutex.go

Let's use the Go sync.Mutex.  It's a drop-in for the semaphore, without
having to think about an initial count value.

## buffered.go

This version is a bit of an intellectual exercise but demonstrates how a
buffered channel can be used as a mutex.  The buffer, `count` here, represents
a place where a value may or may not be stored.  Go does not have strict
concepts of ownership in the way Rust does, for example, but a Go program can
still follow conventions of ownership.  If you follow the convention that
getting the value from the `count` channel means that you "own" it, then you
can receive the value from the channel, increment it, and then send it back
to the channel as a way of relinquishing your ownership of the value.  A
buffer size of one means there can be only one value.  It is a way to implement
mutually exclusive access to a value.

## atomic.go

Really though, if you just want to increment a shared count?  sync/atomic is
the way to go.  No mutex needed.
