# 3.3 Rendezvous Pattern

## book.go

A literal implementation of the book's solution using our library semaphore
implementation.  It's a symmetric solution in that the same function is used
for both goroutines, which is satisfying.  A little detail added to make a nice
working program out of it is the sync.WaitGroup to allow the main program to
wait for both goroutines to complete (their output) before terminating.  More
on WaitGroups later.

## buffered.go

This is `book.go` with Go channels replacing the semaphores.  It's easiest
to make the channels buffered in this case, as that's kind of how semaphores
work.

## chan.go

Finally, "rendezvous" is interpreted variously.  The Ada rendezvous is quite
elaborate with functionality for example.  Sometimes the term means "each
thread sends a message, each thread receives a message, and they each wait
for each other".  But most primitively, it means that each thread must be at
a particular place in it's own code at some same instant, with the first
thread to arrive waiting for the second.  This is exactly what a Go unbuffered
send and receive does.  If you don't mind the asymmetry of one goroutine being
the designated sender and the other being the designated receiver then this
is a simple rendezvous.

In this sense, that exercise 3.1 was a rendezvous as well.  It's unclear at
this point what capability this exercise 3.3 is showing that is new.
